# 防抖和节流

在 JS 性能优化中，`防抖`和`节流`也是其中一环。需要配合定时器一起来使用`setTimeout`

- 防抖：函数在延迟时间内，只执行一次事件，分为延迟执行和立即执行
- 节流：每隔一段时间，函数执行一次，稀释函数执行

# 防抖函数

使用场景就是，表单提交，input 输入内容请求接口等，请看例子

```javascript
/**
 * 延迟执行版本
 * fn: 执行的函数
 * wait: 定时器毫秒
 * **/
function debounce(fn, wait = 300) {
	let timer = null
	return function (...rest) {
		const that = this
		if (timer) {
			console.log("疯狂点击")
			clearTimeout(timer) // 通过清除定时器，重新开始倒计时，来阻止函数多次触发
		}
		timer = setTimeout(() => {
			console.log("执行了")
			fn.apply(that, rest)
			timer = null
		}, wait)
	}
}
/**
 * 立即执行版本
 * fn: 执行的函数
 * wait: 定时器毫秒
 * **/
function debounce(fn, wait = 300) {
	let timer = null
	return function (...rest) {
		if (!timer) {
			console.log("立即执行")
			fn.apply(this, rest)
		}
		clearTimeout(timer) // 通过清除定时器，来阻止函数执行
		timer = setTimeout(() => {
			timer = null
		}, wait)
	}
}
```

函数延迟执行的意思是说，函数执行触发后，定时`300ms`再执行，如果`300ms`内，再次执行函数时，则清除定时器，重新计时`300ms`。</br>
立即执行版本：是说点击时立刻执行函数，延迟时间内，再次执行函数时，此时定时器还没执行借宿，清除定时器，重新计时。

# 节流函数

节流函数会稀释函数的执行，使用场景就是监听滚轮变化，处理一些事情，例子

```javascript
function throttle(fn, wait = 2000) {
	let timer = null
	return function (...rest) {
		if (!timer) {
			fn.apply(this, ...rest)
		}
		if (timer) return false
		timer = setTimeout(() => {
			clearTimeout(timer)
			timer = null
		}, wait)
	}
}
```

节流：在延迟`2000ms`内，多次点击，只会隔段时间(`隔2000ms`)执行一次函数。假如延迟时间执行是`2000ms`, 而你一共点击了`5次`使用了`3s`,此时函数只会执行`2次`，也就是`稀释函数`执行。
