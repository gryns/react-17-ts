# 模块化的导入和导出

`ES6 Module`, `CommonJS` , `AMD`都是用来规范模块化的使用，是用来规范模块化的导入，导出、模块之间的依赖关系和命名空间冲突问题，使项目代码结构更合理、可维护性更高的管理模块

# commonJS

`commonJs`是`nodejs`服务器规范, 每个文件都是模块，引入模块时是同步加载的，使用方法是`module.exports`或者`exports`导出，`require()` 接收。

```javascript
const a = 1
const b = function () {
	console.log("b")
}

module.exports = {
	a: a,
	b: b,
}

const c = require("module-exports")
// c.a , c.b()
```

# ES6 Module

自 ES6 起，JS 引入了新的模块引入规范，使用标准是`export default`和`import`来导出/导入模块。浏览器环境中是可以使用`require`来导入`export`和`export default`导出的模块，这也是为了浏览器和服务端通用的模块解决方案，二者区别

- `export` 可以导出多个 ， `export default`只能导出一个
- `export` 能按需导入, `export default`不能
- `export`导出是使用`{}`导出，`export default`不需要

```javascript
// 导出多个
const a = 1
const b = function () {
	console.log("b")
}
export const c = "c"
export { a, b }
// 导出单个
export default function name() {}

// 导入
import { a, b, c } from "module-more"
import name from "module-name"
import * as otherName from "module-name"
```

# ES Module 和 CommonJs 区别

- ESM 是编译时输出接口，CommonJS 是运行时加载(执行时加载-执行阶段)
- ESM 中 this 指向是 undefined ， CommonJS 中 this 是指当前模块
- ESM 导出的是值的引用，CommonJS 是导出的值的拷贝(原始值拷贝)
- 二者都会缓存模块，再次加载使用缓存里的模块

# 如何理解值得拷贝呢？

js 中基本数据类型，输出一个值，如果模块内发生改变，将不受影响，此时值会被缓存。

# 如何理解编译时输出接口？

在使用`imort`时，只能声明在模块顶层，否则会报错。ESM 又被称为`编译时输出接口`，是因为它的模块解析实在编译阶段

# AMD

`AMD`是浏览器的模块规范，异步加载模块，模块的加载不会阻塞浏览器执行，其 requireJs 实现了`AMD`规范</br>

```javascript
require(["A", "B"], function (A, B) {
	// do ...
})
define(["A", "B"], function (A, B) {
	// do ...
	return {}
})
```

# 参考链接

[ESM 和 CommonJs 区别](https://www.zhihu.com/question/62791509/answer/1535800470)</br>
[深入浅出 ESM 模块 和 CommonJS 模块](https://zhuanlan.zhihu.com/p/466773898)
