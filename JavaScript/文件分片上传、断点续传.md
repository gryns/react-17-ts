# 文件分片上传，断点续传
最近在做分片和断点续传功能，来记录一下书写过程和遇到的问题，本文用到知识点有`文件流(Blod)`,Blod对象下有个`slice()`方法来切片，`FileRader()对象`用来读取文件的内容，`spark-md5`第三方库，来判断上传文件是否是同一个文件，接下来咱们就开始吧
# 实现步骤，这是公司里做法，仅做参考
-   第一步：调用第1个接口开启一个会话，会携带文件md5参数，以便后端比对是否是同一个文件
-   第二步：调用第2个接口轮询调用上传分片接口
-   第三步：当分片上传完成后，调用第3个接口，通知后端做合并分片的操作。
# 前端数据交互格式
前端和后端交互用到的有`XML`，`JSON`，`FormData`,目前使用最多的是`JSON`格式。当需要上传图片和文件时，`JSON`是不能使用的，而`FormData`就可以接收图片和文件类型的数据,提供的是`key:value`格式去接收。使用`JSON`格式时，设置请求头：`content-type: application/json`,而`FormData`的请求头是：`content-type: multipart/form-data`。
# Blob对象（File对象）
`File`对象代表一个文件，用来读取文件信息，它继承了`Blod`对象，所有使用Blod对象的场合都可以使用它。
当你引入`<input type='file'>`标签时，浏览器会生成一个数组，里面是用户选中的文件，它们都是File实例对象。而用户选择文件后files字段里的值就是存放文件流的地方
```JavaScript
// <input type="file" id="input" />
var file = document.getElementById('input').files[0];
file instanceof File // true
```
# FileReader()读取文件内容
用来读取文件内容，其中的一些方法有
```JavaScript
const fileReader = new FileReader()
fileReader.readAsArrayBuffer(file)
fileReader.onload = res =>{
    // res.target.result
}
```
## 方法
- readAsBinaryString(file): 把文件读取结果为二进制（Blod对象或者File对象）（[MDN上说已移除](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsBinaryString)）
- readAsArrayBuffer(file): 把文件读取结果为ArrayBuffer对象

## 事件
- onload: 读取完触发
- onerror: 读取失败触发
- onabort: 终端触发
- onloadend: 无论成功或失败，都触发
- onloadstart: 开始时触发
- onprogress: 读取进度
# spark-md5
只是一个JS库，用来校验是否是同一个文件，生成hash值，这里列举一个方法
```JavaScript
//方法一：file: files[0]
function mD5Hash(file) {
    const fileReader = new FileReader(file)
    return new Promise(resolve =>{
        fileReader.readAsArrayBuffer(file)
        fileReader.onload = function(res){
            const sparkMd5 = new SparkMD5.ArrayBuffer()
            sparkMd5.append(res.target.result)
            const hash = sparkMd5.end()
            resolve(hash)
        }
    })
}

// 方法二：
function mD5Hash(file) {
    const fileReader = new FileReader(file)
    return new Promise(resolve =>{
        fileReader.readAsBinaryString(file)
        fileReader.onload = function(res){
            const sparkMd5 = new SparkMD5()
            sparkMd5.appendBinary(res.target.result)
            const hash = sparkMd5.end()
            resolve(hash)
        }
    })
}
```
# 分片
接下来开始分片工作，
```JavaScript
// 把二进制进行分片 ， 示例：
const chunkFile = (file)=>{
    const totalChunk = 5, // 总共5片
            chunkSize = 1021 // bit 1片大小
    let current = 0, // 下标位置
    curList = []; // 参数存放到数据里
    for(let i = 0 ; i < totalChunk ; i++){
        const item = {
            chunkNo: i,
            chunk: file.slice(current , current+ chunkSize)
        }
        current +=chunkSize
        /**
         * 在第一个接口返回参数里，后端会告诉我们哪些片上传失败，需要和后端对接
         * 例如返回字段：successList: [] , successList: [1,4]
         * 当是空数组，我们全部上传。
         * 当不是空数组, 我们只需上传1、4片即可
         * **/
        curList.push(item)
    }
    return Promise.resolve(curList);
}

// 轮询调用上传接口
const sendFile = async ()=>{
    const sendFiles = await chunkFile(file)
    sendFiles.forEach(element => {
        const formData = new FormData()
        formData.append('chunkNo' , element.chunkNo)
        formData.append('chunk' , element.chunk)
        sendAjax(formData) // 发送接口
        /**
         * 轮询上传时，我们要知道什么时候上传结束，再调用通知后端合并分片操作，此时定义一个变量，当变量和totakChunk相等时，表明全都上传成功了
         * **/ 
    });
}

// axios 请求
const sendAjax = formData =>{
    // 仅做参考
    const params = {
        url,
        data: formData,
        headers:{
            'content-type':'multipart/form-data'
        },
        credentials: 'include'
    }
    axios(params).then(res=>{
        // 成功操作 , 当时是用的hooks ，定一个state 来存储上传成功片个数
        setSuccessChunkNum(num=>{
            return ++num
        })
    })
}

useEffect(()={
    // 监听上传成功片个数，调用通知接口
},[successChunkNum])

```
# 结语
大致都是这样了